vault:
  enabled: true

  global:
    imageRegistry: ""
    ## imagePullSecrets:
    ##   - myRegistryKeySecretName
    ##
    imagePullSecrets: []
    storageClass: ""
    compatibility:
      openshift:
        adaptSecurityContext: auto

  kubeVersion: ""
  nameOverride: ""
  fullnameOverride: ""
  namespaceOverride: ""
  commonLabels: {}
  commonAnnotations: {}
  clusterDomain: cluster.local
  diagnosticMode:
    enabled: false
    command:
      - sleep
    args:
      - infinity
  ##
  server:
    enabled: true
    replicaCount: 1
    ## @param server.podManagementPolicy Pod management policy
    ## Should be initialized one by one when building the replicaset for the first time
    ##
    podManagementPolicy: Parallel
    containerPorts:
      http: 8200
      internal: 8201

    livenessProbe:
      # As the user needs to manually unseal the server, we don't want Vault to restart
      enabled: false
      initialDelaySeconds: 5
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 5
      successThreshold: 1
    readinessProbe:
      enabled: true
      initialDelaySeconds: 5
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 5
      successThreshold: 1
    startupProbe:
      enabled: false
      initialDelaySeconds: 5
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 5
      successThreshold: 1
    resourcesPreset: "nano"
    ## @param server.resources Set container requests and limits for different resources like CPU or memory (essential for production workloads)
    ## Example:
    ## resources:
    ##   requests:
    ##     cpu: 2
    ##     memory: 512Mi
    ##   limits:
    ##     cpu: 3
    ##     memory: 1024Mi
    ##
    resources: {}
    podSecurityContext:
      enabled: true
      fsGroupChangePolicy: Always
      sysctls: []
      supplementalGroups: []
      fsGroup: 1001
    containerSecurityContext:
      enabled: true
      seLinuxOptions: null
      runAsUser: 1001
      runAsGroup: 1001
      runAsNonRoot: true
      privileged: false
      readOnlyRootFilesystem: true
      allowPrivilegeEscalation: false
      capabilities:
        drop: ["ALL"]
      seccompProfile:
        type: "RuntimeDefault"
    ## @param server.command Override default container command (useful when using custom images)
    ##
    command: []
    ## @param server.args Override default container args (useful when using custom images)
    ##
    args: []
    ## @param server.automountServiceAccountToken Mount Service Account token in pod
    ##
    automountServiceAccountToken: true
    ## @param server.hostAliases Vault Server pods host aliases
    ## https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/
    ##
    hostAliases: []
    ## @param server.config [string] Vault server configuration (evaluated as a template)
    ##
    config: |
      disable_mlock = true
      ui = true
      listener "tcp" {
        tls_disable = 1
        address = "[::]:{{ .Values.server.containerPorts.http }}"
        cluster_address = "[::]:{{ .Values.server.containerPorts.internal }}"
        {{- if .Values.server.metrics.enabled }}
        # Enable unauthenticated metrics access (necessary for Prometheus Operator)
        telemetry {
          unauthenticated_metrics_access = "true"
        }
        {{- end }}
      }
      storage "raft" {
        path = "{{ .Values.server.persistence.mountPath }}"
      }

      service_registration "kubernetes" {}


    service:
      general:
        ## @param server.service.general.type Vault Server service type
        ##
        type: ClusterIP
        ## @param server.service.general.ports.http Vault Server service HTTP port
        ## @param server.service.general.ports.internal Vault Server internal port
        ##
        ports:
          http: 8200
          internal: 8201

        clusterIP: ""
        loadBalancerIP: ""
        loadBalancerSourceRanges: []
        externalTrafficPolicy: Cluster
        annotations: {}
        extraPorts: []
        sessionAffinity: None
        sessionAffinityConfig: {}
      active:
        type: ClusterIP
        ports:
          http: 8200
          internal: 8201
        nodePorts:
          http: ""
          internal: ""
        clusterIP: ""
        loadBalancerIP: ""
        loadBalancerSourceRanges: []
        externalTrafficPolicy: Cluster
        annotations: {}
        extraPorts: []
        sessionAffinity: None
        sessionAffinityConfig: {}
    networkPolicy:
      enabled: true
      kubeAPIServerPorts: [443, 6443, 8443]
      allowExternal: true
      ## @param server.networkPolicy.allowExternalEgress Allow the pod to access any range of port and all destinations.
      ##
      allowExternalEgress: true

    ingress:
      ## @param server.ingress.enabled Enable ingress record generation for Vault
      ##
      enabled: false
      ## @param server.ingress.pathType Ingress path type
      ##
      pathType: ImplementationSpecific
      ## @param server.ingress.apiVersion Force Ingress API version (automatically detected if not set)
      ##
      apiVersion: ""
      ## @param server.ingress.hostname Default host for the ingress record
      ##
      hostname: vault.local
      ## @param server.ingress.ingressClassName IngressClass that will be be used to implement the Ingress (Kubernetes 1.18+)
      ## This is supported in Kubernetes 1.18+ and required if you have more than one IngressClass marked as the default for your cluster .
      ## ref: https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/
      ##
      ingressClassName: ""
      
      ## @param server.ingress.path Default path for the ingress record
      ## NOTE: You may need to set this to '/*' in order to use this with ALB ingress controllers
      ##
      path: /
      ## @param server.ingress.annotations Additional annotations for the Ingress resource. To enable certificate autogeneration, place here your cert-manager annotations.
      ## Use this parameter to set the required annotations for cert-manager, see
      ## ref: https://cert-manager.io/docs/usage/ingress/#supported-annotations
      ## e.g:
      ## annotations:
      ##   kubernetes.io/ingress.class: nginx
      ##   cert-manager.io/cluster-issuer: cluster-issuer-name
      ##
      annotations: {}
      ## @param server.ingress.tls Enable TLS configuration for the host defined at `client.ingress.hostname` parameter
      ## TLS certificates will be retrieved from a TLS secret with name: `{{- printf "%s-tls" .Values.ingress.hostname }}`
      ## You can:
      ##   - Use the `client.ingress.secrets` parameter to create this TLS secret
      ##   - Rely on cert-manager to create it by setting the corresponding annotations
      ##   - Rely on Helm to create self-signed certificates by setting `client.ingress.selfSigned=true`
      ##
      tls: false
      ## @param server.ingress.selfSigned Create a TLS secret for this ingress record using self-signed certificates generated by Helm
      ##
      selfSigned: false
      ## @param server.ingress.extraHosts An array with additional hostname(s) to be covered with the ingress record
      ## e.g:
      ## extraHosts:
      ##   - name: vault.local
      ##     path: /
      ##
      extraHosts: []
      ## @param server.ingress.extraPaths An array with additional arbitrary paths that may need to be added to the ingress under the main host
      ## e.g:
      ## extraPaths:
      ## - path: /*
      ##   backend:
      ##     serviceName: ssl-redirect
      ##     servicePort: use-annotation
      ##
      extraPaths: []
      ## @param server.ingress.extraTls TLS configuration for additional hostname(s) to be covered with this ingress record
      ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
      ## e.g:
      ## extraTls:
      ## - hosts:
      ##     - vault.local
      ##   secretName: vault.local-tls
      ##
      secrets: []
      ## @param server.ingress.extraRules Additional rules to be covered with this ingress record
      ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules
      ## e.g:
      ## extraRules:
      ## - host: example.local
      ##     http:
      ##       path: /
      ##       backend:
      ##         service:
      ##           name: example-svc
      ##           port:
      ##             name: http
      ##
      extraRules: []
    ## @section Vault Server RBAC Parameters
    ##

    ## RBAC configuration
    ##
    rbac:
      ## @param server.rbac.create Specifies whether RBAC resources should be created
      ##
      create: true
    ## ServiceAccount configuration
    ##
    serviceAccount:
      ## @param server.serviceAccount.create Specifies whether a ServiceAccount should be created
      ##
      create: true
      ## @param server.serviceAccount.name The name of the ServiceAccount to use.
      ## If not set and create is true, a name is generated using the common.names.fullname template
      ##
      name: ""
      ## @param server.serviceAccount.annotations Additional Service Account annotations (evaluated as a template)
      ##
      annotations: {}
      ## @param server.serviceAccount.automountServiceAccountToken Automount service account token for the server service account
      ##
      automountServiceAccountToken: false
    ## @section Source Conttroller Persistence Parameters
    ## ref: https://kubernetes.io/docs/concepts/storage/persistent-volumes/
    ##
    persistence:
      enabled: true
      mountPath: /bitnami/vault/data
      storageClass: ""
      accessModes:
        - ReadWriteOnce
      size: 5Gi
      dataSource: {}
      annotations: {}


    ## Prometheus metrics
    ##
    metrics:
      ## @param server.metrics.enabled Enable the export of Prometheus metrics
      ##
      enabled: false
      ## @param server.metrics.annotations [object] Annotations for the server service in order to scrape metrics
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "{{ .Values.server.service.general.ports.http }}"

  injector:
    enabled: true
    replicaCount: 1
    containerPorts:
      https: 8080
    livenessProbe:
      enabled: true
      initialDelaySeconds: 5
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 5
      successThreshold: 1
    readinessProbe:
      enabled: true
      initialDelaySeconds: 5
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 5
      successThreshold: 1
    startupProbe:
      enabled: false
      initialDelaySeconds: 5
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 5
      successThreshold: 1
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    resourcesPreset: "nano"
    ## @param injector.resources Set container requests and limits for different resources like CPU or memory (essential for production workloads)
    ## Example:
    ## resources:
    ##   requests:
    ##     cpu: 2
    ##     memory: 512Mi
    ##   limits:
    ##     cpu: 3
    ##     memory: 1024Mi
    ##
    resources: {}
    podSecurityContext:
      enabled: true
      fsGroupChangePolicy: Always
      sysctls: []
      supplementalGroups: []
      fsGroup: 1001

    containerSecurityContext:
      enabled: true
      seLinuxOptions: null
      runAsUser: 1001
      runAsGroup: 1001
      runAsNonRoot: true
      privileged: false
      readOnlyRootFilesystem: true
      allowPrivilegeEscalation: false
      capabilities:
        drop: ["ALL"]
      seccompProfile:
        type: "RuntimeDefault"
    ## @param injector.command Override default container command (useful when using custom images)
    ##
    command: []
    ## @param injector.args Override default container args (useful when using custom images)
    ##
    args: []
    ## @param injector.automountServiceAccountToken Mount Service Account token in pod
    ##
    automountServiceAccountToken: true
    ## @param injector.hostAliases Vault Kubernetes Injector pods host aliases
    ## https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/
    ##
    hostAliases: []
    ## @param injector.podLabels Extra labels for Vault Kubernetes Injector pods
    ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    ##
    podLabels: {}
    ## @param injector.podAnnotations Annotations for Vault Kubernetes Injector pods
    ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
    ##
    podAnnotations: {}
    ## @param injector.podAffinityPreset Pod affinity preset. Ignored if `injector.affinity` is set. Allowed values: `soft` or `hard`
    ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
    ##
    podAffinityPreset: ""
    ## @param injector.podAntiAffinityPreset Pod anti-affinity preset. Ignored if `injector.affinity` is set. Allowed values: `soft` or `hard`
    ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
    ##
    podAntiAffinityPreset: soft

    pdb:
      create: false
      minAvailable: 1
      maxUnavailable: ""

    autoscaling:
      enabled: false
      minReplicas: ""
      maxReplicas: ""
      targetCPU: ""
      targetMemory: ""


    service:
      ## @param injector.service.type Vault Kubernetes Injector service type
      ##
      type: ClusterIP
      ## @param injector.service.ports.https Vault Kubernetes Injector service HTTPS port
      ##
      ports:
        https: 443
      ## Node ports to expose
      ## @param injector.service.nodePorts.https Node port for HTTPS
      ## NOTE: choose port between <30000-32767>
      ##
      nodePorts:
        https: ""
      ## @param injector.service.clusterIP Vault Kubernetes Injector service Cluster IP
      ## e.g.:
      ## clusterIP: None
      ##
      clusterIP: ""
      ## @param injector.service.loadBalancerIP Vault Kubernetes Injector service Load Balancer IP
      ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-loadbalancer
      ##
      loadBalancerIP: ""
      ## @param injector.service.loadBalancerSourceRanges Vault Kubernetes Injector service Load Balancer sources
      ## ref: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service
      ## e.g:
      ## loadBalancerSourceRanges:
      ##   - 10.10.10.0/24
      ##
      loadBalancerSourceRanges: []
      ## @param injector.service.externalTrafficPolicy Vault Kubernetes Injector service external traffic policy
      ## ref http://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-web-source-ip
      ##
      externalTrafficPolicy: Cluster
      ## @param injector.service.annotations Additional custom annotations for Vault Kubernetes Injector service
      ##
      annotations: {}
      ## @param injector.service.extraPorts Extra ports to expose in Vault Kubernetes Injector service (normally used with the `sidecars` value)
      ##
      extraPorts: []
      ## @param injector.service.sessionAffinity Control where web requests go, to the same pod or round-robin
      ## Values: WebIP or None
      ## ref: https://kubernetes.io/docs/concepts/services-networking/service/
      ##
      sessionAffinity: None
      ## @param injector.service.sessionAffinityConfig Additional settings for the sessionAffinity
      ## sessionAffinityConfig:
      ##   webIP:
      ##     timeoutSeconds: 300
      ##
      sessionAffinityConfig: {}
